<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-dropdown/paper-dropdown.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-in-animation.html">
<link rel="import" href="../services/matchupService.html">
<link rel="import" href="../shared-styles.html">
<link rel="import" href="../reduxMixin.html">
<link rel="import" href="../vendor/lodash.html">
<link rel="import" href="../mixins/formatterMixin.html">

<dom-module id="gfdt-matchup-list-item">
  <template>
    <style include="shared-styles">
      .winner {
        color: green
      }

      .loser {
        color: red
      }

      .draw {
        color: blue
      }
    </style>
    <div>
      <h2>[[formatDate(matchup.startDate)]] - [[formatDate(matchup.endDate)]]</h2>
    </div>
    <div style="display:flex">
      <div>
        <span class$="[[getPlayerStyle(battleOne.chooser)]]">[[battleOne.chooser.displayName]] ({{getPlayerScore(battleOne.chooser)}})</span>
        <div>
          [[getSongString(battleOne.song)]]
          <div hidden$="[[isMatchupVerified]]">
            <paper-button hidden$="[[!isSongSelected(battleOne)]]" on-tap="redirectToBattlePage" data-battle$="[[battleOne]]">Submit Score</paper-button>
            <paper-button hidden$="[[!canPickSong(battleOne)]]" on-tap="openSongSelectionDialog" data-battle$="[[battleOne]]">Pick Song</paper-button>
          </div>
          <paper-button hidden$="[[!isMatchupVerified]]" on-tap="redirectToBattlePage" data-battle$="[[battleOne]]">View Results</paper-button>
        </div>
      </div>
      <div style="padding: 0 20px 0 20px">
        <span>VS</span>
      </div>
      <div>
        <span class$="[[getPlayerStyle(battleTwo.chooser)]]">[[battleTwo.chooser.displayName]] ({{getPlayerScore(battleTwo.chooser)}})</span>
        <div>
          [[getSongString(battleTwo.song)]]
          <div hidden$="[[isMatchupVerified]]">
            <paper-button hidden$="[[!isSongSelected(battleTwo)]]" on-tap="redirectToBattlePage" data-battle$="[[battleTwo]]">Submit Score</paper-button>
            <paper-button hidden$="[[!canPickSong(battleTwo)]]" on-tap="openSongSelectionDialog" data-battle$="[[battleTwo]]">Pick Song</paper-button>
          </div>
          <paper-button hidden$="[[!isMatchupVerified]]" on-tap="redirectToBattlePage" data-battle$="[[battleTwo]]">View Results</paper-button>
        </div>
      </div>
      <paper-dialog id="dropdownDialog" entry-animation="fade-in-animation" exit-animation="fade-out-animation" no-cancel-on-outside-click="true">
        <h2>Choose Your Battle Song</h2>
        <paper-dropdown id="selectedSong" label="Select a song" value="{{value}}" searchable>
          <template is="dom-repeat" items="[[songs]]" as="song">
            <paper-item value$="[[song]]">[[song.title]] - [[song.artist]] ([[song.rating]])</paper-item>
          </template>
        </paper-dropdown>
        <div class="buttons">
          <paper-button dialog-dismiss>Cancel</paper-button>
          <paper-button dialog-confirm autofocus on-tap="saveSongSelection">Save</paper-button>
        </div>
      </paper-dialog>
    </div>
  </template>
  <script>
    class MatchupListItem extends FormatterMixin(ReduxMixin(Polymer.Element)) {
      constructor() {
        super()
        this.matchupSvc = new MatchupService()
      }
      isVerified() {
        return !!this.matchup.verification
      }

      isSongSelected(battle) {
        return !!battle.song
      }

      canPickSong(battle) {
        if (battle.song) return false
        if (battle.chooser._id === Store.getState().user._id) {
          return true
        }
        return false
      }

      getSongString(song) {
        if (song) {
          return `${song.title} by ${song.artist}`
        }
        return 'Song Not Chosen, Yet'
      }

      getPlayerScore(player) {
        if (!this.isVerified()) return '??'
        return this.matchup.players.filter(p => p.user._id === player._id)[0].score
      }

      getPlayerStyle(player) {
        if (!this.isVerified()) return

        const thisGuysScore = this.matchup.players.filter(p => p.user._id === player._id)[0].score
        const otherGuysScore = this.matchup.players.filter(p => p.user._id !== player._id)[0].score

        if (thisGuysScore === otherGuysScore) return 'draw'
        if (thisGuysScore > otherGuysScore) return 'winner'
        return 'loser'
      }

      getBattle(matchup, index) {
        return matchup.battles[index]
      }

      redirectToBattlePage(ev) {
        const {battle} = ev.target.dataset
        this.dispatch('selectBattle', this.matchup, JSON.parse(battle))
        Store.getState().routeSubject.next('matchups')
      }

      openSongSelectionDialog(ev) {
        this.$.dropdownDialog.open()
      }

      async saveSongSelection() {
        const songId = JSON.parse(this.$.selectedSong.value)._id
        await this.matchupSvc.chooseSong(this.matchup._id, songId)
      }

      static get is() { return 'gfdt-matchup-list-item'; }
      static get actions() {
        return {
          selectBattle(matchup, battle) {
            return {
              matchup,
              battle,
              type: 'selectMatchupBattle'
            }
          },
        }
      }
      static get properties() {
        return {
          matchup: {
            type: Object
          },
          isMatchupVerified: {
            type: Boolean,
            computed: 'isVerified(matchup.verification)'
          },
          battleOne: {
            type: Object,
            computed: 'getBattle(matchup, 0)'
          },
          battleTwo: {
            type: Object,
            computed: 'getBattle(matchup, 1)'
          },
          songs: {
            type: Array,
            statePath: 'songs'
          }
        }
      }

      static get observers() {
        return [
        ]
      }
    }
    window.customElements.define(MatchupListItem.is, MatchupListItem)
  </script>
</dom-module>